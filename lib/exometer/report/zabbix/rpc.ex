defmodule Exometer.Report.Zabbix.Rpc do
  @moduledoc """
  Zabbix JSON-RPC wrapper
  """
  use GenServer
  require Logger
  alias Exometer.Report.Zabbix.Utils

  @zbx_type_trapper 2
  @default_tmpl_id 1
  @default_tmpl_formatter &Utils.template/1
  @default_app_formatter &Utils.application/1

  @type t :: %__MODULE__{
    url: String.t,
    token: String.t | nil,
    tmpl_parent_id: integer,
    tmpl_formatter: nil,
    app_formatter: nil
  }
  defstruct url: '', token: nil, tmpl_parent_id: @default_tmpl_id, tmpl_formatter: nil, app_formatter: nil

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  def ensure_item(metric, dp, delay) do
    GenServer.call(__MODULE__, {:ensure_metric, metric, dp, delay})
  end

  ###
  ### GenServer callbacks
  ###
  def init(opts) do
    Logger.info("Start Zabbix client")
    user = Keyword.get_lazy(opts, :rpcuser, fn -> raise "missing opt: :rpcuser" end)
    password = Keyword.get(opts, :rpcpassword, fn -> raise "missing opt: :rpcpassword" end)
    url = Keyword.get_lazy(opts, :rpcurl, fn -> raise "missing opt: :rpcurl" end)

    s = %__MODULE__{
      url: '#{url}',
      tmpl_parent_id: Keyword.get(opts, :tmpl_parent_id, @default_tmpl_id),
      tmpl_formatter: Keyword.get(opts, :tmpl_formatter, @default_tmpl_formatter),
      app_formatter: Keyword.get(opts, :app_formatter, @default_app_formatter)
    }
    do_connect(user, password, s)
  end

  def handle_call({:ensure_metric, metric, dp, delay}, _from, s) do
    with {:ok, tmpl_id} <- do_template_id(metric, s),
	 {:ok, _app_id} <- do_application_id(metric, tmpl_id, s),
	 {:ok, item_id} <- do_item_id(metric, dp, delay, tmpl_id, s) do
      {:reply, {:ok, item_id}, s}
    else
      {:error, reason} ->
	Logger.debug("Error creating item: #{inspect reason}")
	{:reply, {:error, reason}, s}
    end
  end
	 
  ###
  ### Priv
  ###
  defp do_connect(user, password, s) do
    Logger.debug("[ZBX] Authentication")
    case rpc_call("user.login", %{ "user" => user, "password" => password }, s) do
      {:ok, token} ->
	Logger.debug("[ZBX] login succesful")
	{:ok, %{ s | token: token }}
      {:error, reason} ->
	Logger.debug("[ZBX] login failed: #{inspect reason}")
	{:error, reason}
    end
  end
  
  defp do_template_id(metric, %__MODULE__{ tmpl_parent_id: tmpl_parent_id, tmpl_formatter: formatter } = s) do
    name = formatter.(metric)
    params = %{ "search" => %{ "name" => name } }
    case rpc_call("template.get", params, s) do
      {:ok, []} ->
	params = %{ "host" => name,
		    "groups" => %{ "groupid" => tmpl_parent_id },
		    "description" => "Generated by exometer" }
	case rpc_call("template.create", params, s) do
	  {:ok, %{ "templateids" => [ id ] }} ->
	    Logger.info("[ZBX] Template '#{name}' created succesfully")
	    {:ok, id}
	    
	  {:error, reason} ->
	    {:error, reason}
	end
	
      {:ok, [ %{ "templateid" => id } | _ ]} ->
	{:ok, id}
    end
  end

  defp do_application_id(metric, tmpl_id, %__MODULE__{ app_formatter: formatter } = s) do
    name = formatter.(metric)
    params = %{ "search" => %{ "name" => name } }
    case rpc_call("application.get", params, s) do
      {:ok, []} ->
	params = %{ "name" => name,
		    "hostid" => tmpl_id }
	case rpc_call("application.create", params, s) do
	  {:ok, %{ "applicationids" => [ id ] }} ->
	    Logger.info("[ZBX] Application '#{name}' created succesfully")
	    {:ok, id}
	    
	  {:error, reason} ->
	    {:error, reason}
	end
	
      {:ok, [ %{ "applicationid" => id } | _ ]} ->
	{:ok, id}
    end
  end

  defp do_item_id(metric, dp, delay, tmpl_id, s) do
    key = Utils.key(metric, dp)
    params = %{ "search" => %{ "key_" => key } }
    case rpc_call("item.get", params, s) do
      {:ok, []} ->
	params = %{ "delay" => delay,
		    "hostid" => tmpl_id,
		    "key_" => key,
		    "name" => "Exometer #{key}",
		    "type" => @zbx_type_trapper,
		    "value_type" => Utils.infer_type(metric, dp),
		    "trapper_hosts" => ""
		  }
	case rpc_call("item.create", params, s) do
	  {:ok, %{ "itemids" => [ item_id ] }} ->
	    Logger.info("[ZBX] Item '#{key}' created succesfully")
	    {:ok, item_id}

	  {:error, reason} ->
	    {:error, reason}
	end
	
      {:ok, [ %{ "itemid" => item_id } | _ ]} ->
	{:ok, item_id}
    end
  end

  defp rpc_call(method, params, %__MODULE__{ url: url, token: token }) do
    Logger.debug("[RPC] call #{url} <#{method}>")
    ct = 'application/json-rpc'
    opts = []
    case :httpc.request(:post, {url, [{'content-type', 'application/json-rpc'}], ct, rpc_encode(method, params, token)}, [], opts) do
      {:ok, {{_vsn, 200, _reason}, _headers, body}} ->
	rpc_decode(body)

      {:ok, {{_vsn, status_code, _reason}, headers, body}} ->
	err = {:http_request_failed, status_code, headers, body}
	{:error, err}

      {:error, reason} ->
	{:error, reason}
    end
  end

  defp rpc_encode(method, params, auth) do
    Poison.encode!(
      %{
	"jsonrpc" => "2.0",
	"method" => method,
	"id" => 1,
	"auth" => auth,
	"params" => params
      })
  end

  defp rpc_decode(body) do
    case Poison.decode(body) do
      {:ok, %{"jsonrpc" => "2.0", "id" => _id, "result" => result}} ->
  	{:ok, result}
	
      {:ok, %{"jsonrpc" => "2.0", "id" => _id, "error" => error}} ->
  	{:error, {error["code"], error["message"], error["data"]}}

      {:ok, response} ->
  	{:error, {:invalid_response, response}}

      {:error, error} ->
  	{:error, error}
    end
  end
end
